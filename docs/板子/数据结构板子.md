# 数据结构板子

## FHQ 树

```cpp
struct fhq {
    const var NN;
    std::vector<var> val, key, ls, rs, siz, space;
    var at, rt;
    fhq(var N = 2e6) : NN(N), 
        val(NN, 0), key(NN, 0),
        ls(NN, 0), rs(NN, 0),
        siz(NN, 0), space(NN, 0) {
        at = 0, rt = 0;
        srand(time(0));
        for (var i = 1; i < NN - 10; i ++) {
            space[++ at] = i;
        }
    }
    var new_node() { return space[at --]; }
    void del_node(var p) { 
        val[p] = key[p] = ls[p] = rs[p] = siz[p] = 0;  
        space[++ at] = p;
    }
    void push_up(var p) {
        if (p == 0) return;
        siz[p] = 1 + siz[ls[p]] + siz[rs[p]];
    }
    void split(var p, var x, var& l, var& r) {
        // 切割出来的左树是严格小于 x
        if (p == 0) { l = r = 0; return; }
        if (val[p] < x) {
            l = p;
            split(rs[p], x, rs[p], r);
        }
        else {
            r = p;
            split(ls[p], x, l, ls[p]);
        }
        push_up(l); push_up(r);
    }
    void meld(var& p, var l, var r) {
        if (!l || !r) {
            p = l + r; push_up(p); return;
        }
        else if (key[l] >= key[r]) {
            p = l; meld(rs[p], rs[p], r);
        }
        else {
            p = r; meld(ls[p], l, ls[p]);
        }
        push_up(p);
    }
    var index(var p, var k) {
        var t = siz[ls[p]] + 1;
        if (k == t) return val[p];
        else if (k > t) return index(rs[p], k - t);
        else return index(ls[p], k);
    }
    void clear(var& p) {
        if (p == 0) return;
        clear(ls[p]);
        clear(rs[p]);
        del_node(p);
        p = 0;
    }
    // 查找下标为 k 的元素，下标从 1 开始
    var index(var k) { return index(rt, k); }
    // 清空整颗树
    void clear() { clear(rt); }
    // 元素个数
    var size() { return siz[rt]; }
    // 插入数据 x
    void insert(var x) {
        var l, r; split(rt, x, l, r);
        var p = new_node();
        val[p] = x;
        key[p] = rand();
        siz[p] = 1;
        meld(rt, l, p);
        meld(rt, rt, r);
    }
    // 删除数据 x，只删一个
    void erase(var x) {
        var l, r; split(rt, x, l, r);
        var p, q; split(r, x + 1, p, q);
        if (p) {
            var l = ls[p], r = rs[p];
            del_node(p); 
            meld(p, l, r);
        }
        meld(rt, l, p);
        meld(rt, rt, q);
    }
    // 删除满足 l <= x <= r 的所有 x
    void erase(var l, var r) {
        var x, y, z;
        split(rt, l, x, y);
        split(y, r + 1, y, z);
        clear(y);
        meld(rt, x, z);
    }
    // 从小到大的排位
    var rank(var x) { 
        var l, r; split(rt, x, l, r);
        var ans = siz[l]; meld(rt, l, r);
        return ans + 1;
    }
    // 获取数据 x 出现的次数
    var count(var x) {
        return rank(x + 1) - rank(x);
    }
};
```
