# [P5091 【模板】扩展欧拉定理](https://www.luogu.com.cn/problem/P5091)

```cpp
#include <bits/stdc++.h>
#define long long long
#define bint __int128

namespace code {

// 欧拉函数
// 求与 n 互质的元素个数
long phi(long n) {
    long res = n;
    long sq = std::sqrt(n);
    for (long i = 2; i <= sq; i ++) {
        if (n % i == 0) {
            res = res / i * (i - 1);
            while (n % i == 0) n /= i;
        }
    }
    if (n > 1) res = res / n * (n - 1);
    return res;
}

// 高精度除法
long div(const std::vector<char>& a, long b, std::vector<char>& c) {
    long t = 0;
    long n = a.size();
    for (long i = n - 1; ~i; i --) {
        t = t * 10 + a[i];
        c.push_back(t / b);
        t %= b;
    }
    c = std::vector<char>(c.rbegin(), c.rend());
    while (c.size() > 1 && c.back() == 0) c.pop_back();
    return t;
}

long a, mod;
std::string b;
std::vector<char> na;
std::vector<char> nc;
long k;

long qpow(long a, long b, long mod) {
    a %= mod; 
    long ans = 1;
    while (b) {
        if (b & 1) ans = ans * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

void solve() {
    std::cin >> a >> mod >> b;
    
    for (long i = (long)b.size() - 1; ~i; i --) {
        na.push_back(b[i] - '0');
    }
    long pi = phi(mod);
    k = div(na, pi, nc) + pi;
    if (b.size() <= 18) {
        long t = 0;
        for (auto c : b) t = t * 10 + c - '0';
        if (t <= pi) k = t;
    }
    std::cout << qpow(a, k, mod) << '\n';
}

}

// g++ -std=c++20 Main.cpp -o Main && ./Main
int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0); std::cout.tie(0);
    //long t; std::cin >> t; while (t --)
    code::solve();
    return 0;
}
```