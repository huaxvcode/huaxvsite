# [P4391 无限传输](https://www.luogu.com.cn/problem/P4391)

字符串哈希求最小循环节，时间复杂的：$O(n)$

```cpp
#include <bits/stdc++.h>
#define ll long long
#define hh __int128

namespace lrq {
    const ll N = 2e6;
    ll R1 = 31, R2 = 131313;
    ll M1 = 1e9 + 7, M2 = 1e9 + 9;
    ll H1[N], H2[N]; // 字符串的哈希值
    ll P1[N], P2[N]; // 进制次方
    std::string s;   // 字符串从 1 开始
    ll n;            // 字符串的长度
    void init() {
        P1[0] = P2[0] = 1;
        for (ll i = 1; i <= n; i ++) {
            P1[i] = P1[i - 1] * R1 % M1;
            P2[i] = P2[i - 1] * R2 % M2;
            H1[i] = (H1[i - 1] * R1 % M1 + s[i]) % M1;
            H2[i] = (H2[i - 1] * R2 % M2 + s[i]) % M2;
        }
    }
    std::pair<ll, ll> get(ll l, ll r) {
        return {
            ((H1[r] - H1[l - 1] * P1[r - l + 1] % M1) % M1 + M1) % M1,
            ((H2[r] - H2[l - 1] * P2[r - l + 1] % M2) % M2 + M2) % M2
        };
    }
    bool check(ll len) {
        ll a = n % len;
        if (a == 0) return true;
        return get(1, a) == get(n - a + 1, n);
    }
    ll get_loop() {
        ll len = 1;
        while (len < n) {
            for (ll i = 1; i + len - 1 <= n; i += len) {
                if (get(i, i + len - 1) != get(1, len)) {
                    len ++; goto lab;
                }
            }
            if (check(len)) break;
            else len ++;
            lab:;
        }
        return len;
    }
}

namespace {

ll n; std::string s;

void solve() {
    std::cin >> n >> s;
    s = ' ' + s;
    lrq::n = n; 
    lrq::s = s;
    lrq::init();
    std::cout << lrq::get_loop() << '\n';
}

}

// g++ -std=c++20 Test.cpp -o Test && ./Test
int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0); std::cout.tie(0);
    //long t; std::cin >> t; while (t --)
    solve();
    return 0;
}

```
