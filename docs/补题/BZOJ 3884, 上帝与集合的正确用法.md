# [BZOJ 3884, 上帝与集合的正确用法](http://oj.daimayuan.top/course/28/problem/535)

令 $f = 2 ^ f$，求 $f \bmod p$ 的值为多少，无限套娃

---

> $f = 2 ^ f (\bmod \ p)$
>
> $f = 2 ^ {(f \bmod phi(p) + phi(p))} (\bmod \ p)$
>
> 接下来就是求：
>
> $f \bmod phi(p)$ 的值，一直套娃下去

---

接下来需要探究：

令 $f = phi(f)$ 因为 $phi(f)$ 是严格单调递减的函数，且 $phi(f) \geq 1$，所以一定会存在某步后，$phi(f) = 1$

```cpp
#include <bits/stdc++.h>
#define long long long
#define bint __int128

namespace {

long n;

long phi(long n) {
    long ans = n;
    for (long i = 2; i * i <= n; i ++) {
        if (n % i == 0) {
            ans = ans / i * (i - 1);
            while (n % i == 0) n /= i;
        }
    }
    if (n > 1) ans = ans / n * (n - 1);
    return ans;
}

long qpow(long a, long b, long mod) {
    long ans = 1;
    a %= mod;
    while (b) {
        if (b & 1) ans = ans * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

void solve() {
    std::cin >> n;
    auto dfs = [&](auto&& f, long mod) -> long {
        if (mod == 1) return 0;
        return qpow(2, f(f, phi(mod)) + phi(mod), mod);
    };
    std::cout << dfs(dfs, n) << '\n';
}

}

// g++ -std=c++20 Main.cpp -o Main && ./Main
int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0); std::cout.tie(0);
    long t; std::cin >> t; while (t --)
    solve();
    return 0;
}

```