# [奇数个 1 的子串的总长度](https://www.luogu.com.cn/problem/U368658)

动态规划，先求出以 $i$ 结尾的后缀含有奇数个 $1$ 的子串的总个数，然后再求出以 $i$ 结尾的后缀含有奇数个 $1$ 的子串的总长度.

```cpp
#include <bits/stdc++.h>
typedef long long var;
typedef __int128 hh;

namespace {

const var N = 5e6;
const var mod = 1e9 + 7;
var n;
std::string s;
var dp[3][N];
var dps[3][N];
var res;

// 求含有奇数个 1 的子串的总长度
void solve() {
    std::cin >> n >> s; s = ' ' + s;
    for (var i = 1; i <= n; i ++) {
        if (s[i] - '0') {
            if (i == 1) {
                dp[1][i] = 1;
                dps[1][i] = 1;
                continue;
            }
            dp[1][i] = (dp[2][i - 1] + 1 + dp[0][i - 1]) % mod;
            dp[2][i] = dp[1][i - 1] % mod;
            dps[1][i] = (dps[2][i - 1] + dp[2][i - 1] + 1 + dp[0][i - 1] * (dp[0][i - 1] + 1) / 2 + dp[0][i - 1]) % mod;
            dps[2][i] = (dps[1][i - 1] + dp[1][i - 1]) % mod;
        }
        else {
            dp[1][i] = dp[1][i - 1];
            dp[2][i] = dp[2][i - 1];
            dp[0][i] = dp[0][i - 1] + 1;
            dps[1][i] = (dps[1][i - 1] + dp[1][i]) % mod;
            dps[2][i] = (dps[2][i - 1] + dp[2][i]) % mod;
        }
    }
    for (var i = 1; i <= n; i ++) res += dps[1][i], res %= mod;
    std::cout << res << '\n';
}

}

// g++ -std=c++20 Main.cpp -o Main && Main
int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0); std::cout.tie(0);
    //int t; std::cin >> t; while (t --)
    solve();
    return 0;
}

```
